<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
        <title>A game of tokens: solution - Part 1 - hydrphlc</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<!--<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">-->
		<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,600,400italic,600italic|Roboto+Slab:400,700">

        <link rel="stylesheet" href="/theme/css/main.min.css?04100d07">


        <link href="/images/global/favicon.jpg" rel="icon">


<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Article",
  "name" : "A game of tokens: solution - Part 1",
  "author" : {
    "@type" : "Person",
    "name" : "David G"
  },
  "publisher" : {
    "@type" : "Organization",
    "name" : "The Digital Cat",
    "logo" : {
      "@type" : "ImageObject",
      "url" : "../../../../../images/global/logo_200.jpg",
      "height" : 200,
      "width" : 200
    }
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "../../../../../blog/2017/07/12/a-game-of-tokens-solution-part-1/"
  },
  "datePublished" : "12/07/2017",
  "dateModified" : "12/07/2017",
  "image" : "../../../../../images/a-game-of-tokens-solutions.jpg",
  "url" : "../../../../../blog/2017/07/12/a-game-of-tokens-solution-part-1/"
}
</script>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">
						<div class="inner">

    <header id="header">
        <a class="logo" href="/category/programming/" title="Programming">All posts in category Programming <i class="fa fa-link"></i></a>
        <div class="align-right">
            
            
            A game of tokens #1


        </div>
    </header>

    <!-- <article class="post"> -->

    <section id="header">
        <header class="main">
            <h1>A game of tokens: solution - Part 1</h1>
        </header>
    </section>

    <section id="post-info">
        <div class="align-center">
            <a class="button special small" href="/categories/python/">Python</a>            <a class="button special small" href="/categories/python3/">Python3</a>            <a class="button special small" href="/categories/tdd/">TDD</a>            <a class="button special small" href="/categories/testing/">testing</a>            <a class="button special small" href="/categories/compilers/">compilers</a>        </div>

        <div class="align-center">
            By David G
            <span class="separator">â€¢</span>

            Published on <time datetime="2017-07-12T10:00:00+01:00"> 12/07/2017</time>

        </div>
    </section>

    <section id="content">
        <p>This is my solution of the challenge posted <a href="{filename}a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-1.markdown">here</a>. As I stressed in that post, this is just <strong>one</strong> possible solution, and not even necessarily the best one. I provide it to show how I managed to solve the tests and how I worked in a TDD way.</p>
<p>Speaking of TDD I realised that I hadn't followed it very strictly, as sometimes I wrote more code than needed, usually forecasting future changes. I do not believe in a inflexible and uncompromising application of rules, so I do not consider this a big issue, as long as the result is a working code that is not blatantly overengineered.</p>
<p>You can find the code for this part in <a href="https://github.com/lgiordani/smallcalc">this repository</a>. The branch called <code>part1</code> contains all the commits explained in this post, and every commit contains both the test(s) and the code that makes the test(s) pass.</p>
<h1 id="level-1-end-of-file">Level 1 - End of file<a class="headerlink" href="#level-1-end-of-file" title="Permanent link">&para;</a></h1>
<p>The base class to pass the test leverages the provided <code>text_buffer.TextBuffer</code> class, that exposes a <code>load()</code> method, directly composed here to <code>CalcLexer.load()</code>. As the test is not providing a text the easiest solution is just to return the tested token. I extracted <code>get_token()</code> from <code>get_tokens()</code> to have a method that is specifically focused on dealing with the current token. The file <code>smallcalc/calc_lexer.py</code> is then</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">smallcalc</span> <span class="kn">import</span> <span class="n">text_buffer</span>
<span class="kn">from</span> <span class="nn">smallcalc</span> <span class="kn">import</span> <span class="n">tok</span> <span class="k">as</span> <span class="n">token</span>

<span class="n">EOF</span> <span class="o">=</span> <span class="s1">&#39;EOF&#39;</span>


<span class="k">class</span> <span class="nc">CalcLexer</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span> <span class="o">=</span> <span class="n">text_buffer</span><span class="o">.</span><span class="n">TextBuffer</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_token</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_token</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">EOF</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_token</span>

    <span class="k">def</span> <span class="nf">get_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_token</span><span class="p">()]</span>
</pre></div>


<h1 id="level-2-single-digit-integers">Level 2 - Single digit integers<a class="headerlink" href="#level-2-single-digit-integers" title="Permanent link">&para;</a></h1>
<h2 id="lexer">Lexer<a class="headerlink" href="#lexer" title="Permanent link">&para;</a></h2>
<p>The two functions <code>get_token()</code> and <code>get_tokens()</code> have to evolve to deal with the new requirements, and to avoid having too much code in a single function I created some private helpers (where "private" has the Python meaning of "please don't use them").</p>
<p>The idea behind <code>get_tokens()</code> is to call <code>get_token()</code> until the <code>EOF</code> token is returned, even though we want the latter to be present in the final result.</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">get_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="s1">&#39;EOF&#39;</span><span class="p">):</span>
            <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>

        <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="s1">&#39;EOF&#39;</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">tokens</span>
</pre></div>


<p>Then I decided to make <code>get_token()</code> the central hub of my process with the following paradigm: the function tries to extract a specific token and to return it; if the token cannot be extracted, the function tries with the following.</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">get_token</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">eof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_eof</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">eof</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">eof</span>

        <span class="n">eol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_eol</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">eol</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">eol</span>

        <span class="n">integer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_integer</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">integer</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">integer</span>
</pre></div>


<p>The three helpers shall just try to extract and return the token they have been assigned or None. After some refactoring I came up with three functions (two of them as properties) that simplify common tasks. <code>_current_char</code> and <code>_current_line</code> are just wrappers around two attributes of <code>self._text_storage</code>, while <code>_set_current_token_and_skip()</code> is a bit more complex and ensures that the <code>_current_token</code> is always up to date.</p>
<div class="highlight"><pre><span></span>    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_current_char</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span><span class="o">.</span><span class="n">current_char</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_current_line</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span><span class="o">.</span><span class="n">current_line</span>

    <span class="k">def</span> <span class="nf">_set_current_token_and_skip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_current_token</span> <span class="o">=</span> <span class="n">token</span>
        <span class="k">return</span> <span class="n">token</span>
</pre></div>


<p>Once this functions are in place I can write the actual helpers for the token extraction. <code>_process_eol()</code> leverages <code>self._text_storage</code>, which raises an <code>EOLError</code> when the end of line has been reached. So all I need to do is to try to get the current char and return None if nothing happens. In case of <code>EOLError</code> exception I run <code>_set_current_token_and_skip()</code> with the end of line token.</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">_process_eol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_char</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">except</span> <span class="n">text_buffer</span><span class="o">.</span><span class="n">EOLError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span><span class="o">.</span><span class="n">newline</span><span class="p">()</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_current_token_and_skip</span><span class="p">(</span>
                <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">EOL</span><span class="p">)</span>
            <span class="p">)</span>
</pre></div>


<p>The helper to process the end of file, <code>_process_eof()</code> is exactly like <code>_process_eol()</code>, using <code>self._current_line</code> and <code>text_buffer.EOFError</code>.</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">_process_eof</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_line</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">except</span> <span class="n">text_buffer</span><span class="o">.</span><span class="n">EOFError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_current_token_and_skip</span><span class="p">(</span>
                <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">EOF</span><span class="p">)</span>
            <span class="p">)</span>
</pre></div>


<p>At this point of the development the incoming token can only be <code>EOL</code>, <code>EOF</code>, or an integer. So the <code>_process_integer()</code> function doesn't need to return <code>None</code>. So I just create an integer token with the current char and return it.</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">_process_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_current_token_and_skip</span><span class="p">(</span>
            <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">INTEGER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_char</span><span class="p">)</span>
        <span class="p">)</span>
</pre></div>


<p>The above methods use two new global variables <code>EOL</code> and <code>INTEGER</code> that are defined at the beginning of the file along with <code>EOF</code></p>
<div class="highlight"><pre><span></span><span class="n">EOL</span> <span class="o">=</span> <span class="s1">&#39;EOL&#39;</span>
<span class="n">INTEGER</span> <span class="o">=</span> <span class="s1">&#39;INTEGER&#39;</span>
</pre></div>


<h2 id="parser">Parser<a class="headerlink" href="#parser" title="Permanent link">&para;</a></h2>
<p><code>CalcParser</code> is the only class that is tested, but forecasting (actually, knowing) that we are going to manage multiple types of nodes, I isolated the code for the <code>IntegerNode</code> in its own class. There is no need yet to abstract things further, however, so <code>IntegerNode</code> doesn't inherit from any other class.</p>
<p>From a pure TDD point of view this is wrong, because I should have written some tests for the <code>IntegerNode</code> class before writing it. The purpose of this exercise, however is to guide you through the creation of a simple compiler, so tests are already given, and I will turn a blind eye on my own exception to the rule (how convenient!).</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">smallcalc</span> <span class="kn">import</span> <span class="n">calc_lexer</span> <span class="k">as</span> <span class="n">clex</span>


<span class="k">class</span> <span class="nc">IntegerNode</span><span class="p">:</span>
    <span class="n">node_type</span> <span class="o">=</span> <span class="s1">&#39;integer&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_type</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
        <span class="p">}</span>


<span class="k">class</span> <span class="nc">CalcParser</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span> <span class="o">=</span> <span class="n">clex</span><span class="o">.</span><span class="n">CalcLexer</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">parse_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">IntegerNode</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
</pre></div>


<h2 id="visitor">Visitor<a class="headerlink" href="#visitor" title="Permanent link">&para;</a></h2>
<p><code>CalcVisitor</code> is by far the simplest class at the moment, as the only node we are managing is the one with an <code>integer</code> type.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CalcVisitor</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;integer&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>
</pre></div>


<h1 id="level-3-binary-operations-addition">Level 3 - Binary operations: addition<a class="headerlink" href="#level-3-binary-operations-addition" title="Permanent link">&para;</a></h1>
<h2 id="lexer_1">Lexer<a class="headerlink" href="#lexer_1" title="Permanent link">&para;</a></h2>
<p>The <code>_process_literal()</code> helper does what <code>_process_integer()</code> did before, which is to blindly return a token, this time with the <code>LITERAL</code> type.</p>
<div class="highlight"><pre><span></span><span class="n">LITERAL</span> <span class="o">=</span> <span class="s1">&#39;LITERAL&#39;</span>
</pre></div>


<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">_process_literal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_current_token_and_skip</span><span class="p">(</span>
            <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">LITERAL</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_char</span><span class="p">)</span>
        <span class="p">)</span>
</pre></div>


<p>The <code>_process_integer()</code> helper, on the other hand, changes to return <code>None</code> when no integer can be parsed, which is easily checked with <code>isdigit()</code>.</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">_process_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_char</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_current_token_and_skip</span><span class="p">(</span>
            <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">INTEGER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_char</span><span class="p">)</span>
        <span class="p">)</span>
</pre></div>


<p>Last, the <code>get_token()</code> method, which adds <code>_process_literal</code> as an additional case.</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">get_token</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">eof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_eof</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">eof</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">eof</span>

        <span class="n">eol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_eol</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">eol</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">eol</span>

        <span class="n">integer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_integer</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">integer</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">integer</span>

        <span class="n">literal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_literal</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">literal</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">literal</span>
</pre></div>


<h2 id="parser_1">Parser<a class="headerlink" href="#parser_1" title="Permanent link">&para;</a></h2>
<p>The parser needs a node that represents the literal, namely <code>LiteralNode</code>, and a node to represent a binary operation, called <code>BinaryNode</code>. To avoid duplicating methods I created the <code>ValueNode</code> class and made both <code>IntegerNode</code> and <code>LiteralNode</code> inherit from that.</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">smallcalc</span> <span class="kn">import</span> <span class="n">calc_lexer</span> <span class="k">as</span> <span class="n">clex</span>


<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{}</span>  <span class="c1"># pragma: no cover</span>


<span class="k">class</span> <span class="nc">ValueNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>

    <span class="n">node_type</span> <span class="o">=</span> <span class="s1">&#39;value_node&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_type</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
        <span class="p">}</span>


<span class="k">class</span> <span class="nc">IntegerNode</span><span class="p">(</span><span class="n">ValueNode</span><span class="p">):</span>
    <span class="n">node_type</span> <span class="o">=</span> <span class="s1">&#39;integer&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">LiteralNode</span><span class="p">(</span><span class="n">ValueNode</span><span class="p">):</span>

    <span class="n">node_type</span> <span class="o">=</span> <span class="s1">&#39;literal&#39;</span>


<span class="k">class</span> <span class="nc">BinaryNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>

    <span class="n">node_type</span> <span class="o">=</span> <span class="s1">&#39;binary&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

    <span class="k">def</span> <span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_type</span><span class="p">,</span>
            <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>

        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;operator&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s1">&#39;operator&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">result</span>
</pre></div>


<p>The most important change, however, is in <code>CalcParser</code>, where I added the <code>parse_addsymbol()</code> and <code>parse_expression()</code> methods.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CalcParser</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span> <span class="o">=</span> <span class="n">clex</span><span class="o">.</span><span class="n">CalcLexer</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">parse_addsymbol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">LiteralNode</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">IntegerNode</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_integer</span><span class="p">()</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_addsymbol</span><span class="p">()</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_integer</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">BinaryNode</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
</pre></div>


<h2 id="visitor_1">Visitor<a class="headerlink" href="#visitor_1" title="Permanent link">&para;</a></h2>
<p>The visitor has to add the processing code for <code>binary</code> nodes, which assumes the operation can only be a sum, so just needs to visit the left and right nodes.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CalcVisitor</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;integer&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;binary&#39;</span><span class="p">:</span>
            <span class="n">lvalue</span><span class="p">,</span> <span class="n">ltype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">])</span>
            <span class="n">rvalue</span><span class="p">,</span> <span class="n">rtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">lvalue</span> <span class="o">+</span> <span class="n">rvalue</span><span class="p">,</span> <span class="n">rtype</span>
</pre></div>


<h1 id="level-4-multi-digit-integers">Level 4 - Multi-digit integers<a class="headerlink" href="#level-4-multi-digit-integers" title="Permanent link">&para;</a></h1>
<p>To provide support for multi-digit integers we just need to change the <code>_process_integer()</code> method of the lexer. The new version makes use of a very simple regular expressions.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>
</pre></div>


<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">_process_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">regexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;\d+&#39;</span><span class="p">)</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">regexp</span><span class="o">.</span><span class="n">match</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span><span class="o">.</span><span class="n">tail</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="n">token_string</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_current_token_and_skip</span><span class="p">(</span>
            <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">INTEGER</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">token_string</span><span class="p">))</span>
        <span class="p">)</span>
</pre></div>


<h1 id="level-5-whitespaces">Level 5 - Whitespaces<a class="headerlink" href="#level-5-whitespaces" title="Permanent link">&para;</a></h1>
<p>To process whitespaces I needed to add a helper called <code>_process_whitespace()</code> with the same structure of the new <code>_process_integer()</code>.</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">_process_whitespace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">regexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;\ +&#39;</span><span class="p">)</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">regexp</span><span class="o">.</span><span class="n">match</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span><span class="o">.</span><span class="n">tail</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()))</span>
</pre></div>


<p>As this time I am not interested in returning whitespace tokens, but I just want to skip them, the helper is added to <code>get_token()</code> without a <code>return</code> statement.</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">get_token</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">eof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_eof</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">eof</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">eof</span>

        <span class="n">eol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_eol</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">eol</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">eol</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_process_whitespace</span><span class="p">()</span>

        <span class="n">integer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_integer</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">integer</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">integer</span>

        <span class="n">literal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_literal</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">literal</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">literal</span>
</pre></div>


<h1 id="level-6-subtraction">Level 6 - Subtraction<a class="headerlink" href="#level-6-subtraction" title="Permanent link">&para;</a></h1>
<p>Adding the addition binary operation changed code in the lexer, the parser, and in the visitor. That operation was however considered a generic binary operation, and only the visitor implements the actual <code>+</code> operation. So adding the subtraction works out of the box for the first two stages and requires me to change the visitor only, with a simple <code>if</code> condition on the value of the operator.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CalcVisitor</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;integer&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;binary&#39;</span><span class="p">:</span>
            <span class="n">lvalue</span><span class="p">,</span> <span class="n">ltype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">])</span>
            <span class="n">rvalue</span><span class="p">,</span> <span class="n">rtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">])</span>

            <span class="n">operator</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;operator&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lvalue</span> <span class="o">+</span> <span class="n">rvalue</span><span class="p">,</span> <span class="n">rtype</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lvalue</span> <span class="o">-</span> <span class="n">rvalue</span><span class="p">,</span> <span class="n">rtype</span>
</pre></div>


<h1 id="level-7-multiple-operations">Level 7 - Multiple operations<a class="headerlink" href="#level-7-multiple-operations" title="Permanent link">&para;</a></h1>
<p>I made no assumptions on the length of the tokens stream in <code>get_tokens()</code>, so processing multiple tokens comes out of the box inn the lexer.</p>
<p>Adding <code>stash()</code> and <code>pop()</code> is not very complex, as the tests show exactly what we need to save and retrieve. Here I leverage the <code>position</code> attribute and the <code>goto</code> functions of the <code>TextBuffer</code> class.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CalcLexer</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span> <span class="o">=</span> <span class="n">text_buffer</span><span class="o">.</span><span class="n">TextBuffer</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_status</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_token</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="p">[</span><span class="o">...</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_current_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">status</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">status</span><span class="p">[</span><span class="s1">&#39;text_storage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span><span class="o">.</span><span class="n">position</span>
        <span class="n">status</span><span class="p">[</span><span class="s1">&#39;current_token&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_token</span>
        <span class="k">return</span> <span class="n">status</span>

    <span class="k">def</span> <span class="nf">stash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_status</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_status</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_status</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span><span class="o">.</span><span class="n">goto</span><span class="p">(</span><span class="o">*</span><span class="n">status</span><span class="p">[</span><span class="s1">&#39;text_storage&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_token</span> <span class="o">=</span> <span class="n">status</span><span class="p">[</span><span class="s1">&#39;current_token&#39;</span><span class="p">]</span>
</pre></div>


<p>Once <code>stash()</code> and <code>pop()</code> are in place implementing <code>peek_token()</code> is trivial</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">peek_token</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stash</span><span class="p">()</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">token</span>
</pre></div>


<p>Finally, <code>peek_token()</code> allows me to add support for multiple expressions in the parser.</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">parse_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_integer</span><span class="p">()</span>

        <span class="n">next_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">peek_token</span><span class="p">()</span>

        <span class="k">while</span> <span class="n">next_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">clex</span><span class="o">.</span><span class="n">LITERAL</span><span class="p">:</span>
            <span class="n">operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_addsymbol</span><span class="p">()</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_integer</span><span class="p">()</span>

            <span class="n">left</span> <span class="o">=</span> <span class="n">BinaryNode</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

            <span class="n">next_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">peek_token</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">left</span>
</pre></div>


<h1 id="final-words">Final words<a class="headerlink" href="#final-words" title="Permanent link">&para;</a></h1>
<p>Again, it is worth mentioning that this solution of mine is just one of the possible ones, not the <strong>correct</strong> one. If your code passes the tests it is correct; it can be ugly, overengineered, slow, but definitely correct. I hope that reading my solution helped you better understand the underlying concepts of lexer, parser, and visitor. Feel free to get in touch if you want to discuss your solution or if you have questions about the code I posted here.</p>
<h1 id="updates">Updates<a class="headerlink" href="#updates" title="Permanent link">&para;</a></h1>
<p>2017-12-24: As mentioned in the updates section of the previous post, Victor Uriarte spotted an error in <code>parse_expression()</code>. The previous version was building a right-growing tree instead of a left-growing one. The current version is correct and corretly handles cases like the one that Victor pointed out in the <a href="https://github.com/lgiordani/smallcalc/issues/4">issue</a> he posted. Thanks Victor!</p>
<h1 id="feedback">Feedback<a class="headerlink" href="#feedback" title="Permanent link">&para;</a></h1>
<p>Feel free to use <a href="https://plus.google.com/u/0/111444750762335924049">the blog Google+ page</a> to comment the post. Feel free to reach me on <a href="https://twitter.com/thedigicat">Twitter</a> if you have questions. The <a href="https://github.com/TheDigitalCatOnline/thedigitalcatonline.github.com/issues">GitHub issues</a> page is the best place to submit corrections.</p>
    </section>

    <section id="related">

        <h1>Part 1 of the A game of tokens series</h1>
        <div class="box">
        
        </div>
    </section>



    <!-- </article> -->

						</div>
					</div>

				<!-- Sidebar -->
					<div id="sidebar">
<div class="inner">
    <!-- Menu -->
        <nav id="menu">
            <header class="major">
                <h2>Menu</h2>
            </header>
<ul>
    <li><a href="/home/">Homepage</a></li>
    <li><a href="/pages/about.html">About</a></li>
    <!--<li><a href="/archives/index.html">Archives</a></li>-->
    <li>
        <span class="opener">Categories</span>
        <ul>
            <li><a href="/category/nature/">Nature</a></li>
            <li><a href="/category/programming/">Programming</a></li>
        </ul>
    </li>
</ul>        </nav>

    <!-- Section -->
        <section>
            <header class="major">
                <h2>Feeds</h2>
            </header>
<ul class="list-clean">


</ul>        </section>

    <!-- Section -->
        <section>
            <header class="major">
                <h2>Tags</h2>
            </header>
<ul class="list-inline list-clean" id="tags-side">
    <li class="tag font-size-4">
        <a href="/categories/beach/">Beach</a>
    </li>
    <li class="tag font-size-4">
        <a href="/categories/compilers/">compilers</a>
    </li>
    <li class="tag font-size-4">
        <a href="/categories/decorators/">decorators</a>
    </li>
    <li class="tag font-size-0">
        <a href="/categories/functional-programming/">functional programming</a>
    </li>
    <li class="tag font-size-4">
        <a href="/categories/metaclasses/">metaclasses</a>
    </li>
    <li class="tag font-size-4">
        <a href="/categories/metaprogramming/">metaprogramming</a>
    </li>
    <li class="tag font-size-4">
        <a href="/categories/notebook/">Notebook</a>
    </li>
    <li class="tag font-size-3">
        <a href="/categories/oop/">OOP</a>
    </li>
    <li class="tag font-size-4">
        <a href="/categories/parks/">Parks</a>
    </li>
    <li class="tag font-size-2">
        <a href="/categories/python/">Python</a>
    </li>
    <li class="tag font-size-4">
        <a href="/categories/python2/">Python2</a>
    </li>
    <li class="tag font-size-2">
        <a href="/categories/python3/">Python3</a>
    </li>
    <li class="tag font-size-0">
        <a href="/categories/scala/">Scala</a>
    </li>
    <li class="tag font-size-4">
        <a href="/categories/tdd/">TDD</a>
    </li>
    <li class="tag font-size-4">
        <a href="/categories/testing/">testing</a>
    </li>
</ul>        </section>

    <!-- Section -->
        <section>
            <header class="major">
                <h2>Other posts</h2>
            </header>
<div class="mini-posts">
    <article>
        <a href="/blog/2016/04/03/abstract-base-classes-in-python/" class="image"><img src="/images/abstract-base-classes.jpg" alt="abstract-base-classes" /></a>
        <p><strong>Abstract Base Classes in Python</strong> <a href="/blog/2016/04/03/abstract-base-classes-in-python/">Read</a></p> 
    </article>
    <article>
        <a href="/blog/2015/01/12/accessing-attributes-in-python/" class="image"><img src="/images/accessing-attributes-in-python.jpg" alt="accessing-attributes-in-python" /></a>
        <p><strong>Accessing attributes in Python</strong> <a href="/blog/2015/01/12/accessing-attributes-in-python/">Read</a></p> 
    </article>
</div>        </section>

    <!-- Section -->
        <section>
            <header class="major">
                <h2>Get in touch</h2>
            </header>
<ul class="contact">



    <li class="fa fa-twitter"><a href="/">Twitter</a></li>




    <li class="fa fa-github"><a href="/">GitHub</a></li>

</ul>        </section>

    <!-- Footer -->
        <footer id="footer">
            <!--<p class="copyright">Editorial theme by: <a href="https://html5up.net">HTML5 UP</a>.</p>
            <p class="copyright">Cover picture by: <a href="https://pxhere.com/en/photo/1428515">An Min @ pxhere.com</a></p>-->
        </footer>

</div>					</div>

			</div>

		<!-- Scripts -->
			<script src="/theme/js/jquery.min.js"></script>
			<script src="/theme/js/browser.min.js"></script>
			<script src="/theme/js/breakpoints.min.js"></script>
            <script src="/theme/js/packed.js?fa89ff81"></script>

	</body>
</html>